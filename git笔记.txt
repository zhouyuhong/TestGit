Git 教程：
git是一个分布式版本控制系统，并且是现在最流行的，最优秀的版本控制系统。
所谓分布式，即每一个用户都是一个完整的仓库，互不影响，如果此时有两个用户对同一个文件进行修改，git仅仅只需要让这两个用户互相推出自己的修改部分给对方即可，当然，实际开发中，我们很少直接面对面的进行推出，而是通过一个中间服务器进行推送，但是这个服务器仅仅承担推送的任务，没有它，git依旧可以运行。
这就有别于传统的集成式版本控制系统CVS、SVN，这两个被称为集成式的版本控制系统，与git最大的区别是它必须要一个服务里来作为版本管理中心，即仓库，用户必须从这个仓库下载文件，修改后也要提交到这个仓库中心才行，所以这就造成了一个弊端，即必须要有一个服务器，同时电脑必须能上网（局域网，广域网），如果没有这些条件，你是不能使用它们的。
这就是集成式版本控制系统与分布式版本控制系统的区别，虽然我们提到，git也有一个中间服务器，但是我们说过，这个服务器的作用仅仅是进行推送信息，即使没有它，git依旧能够完美运行。


git用法：
首先创建一个空文件夹，然后运行
git init

此时在这个文件夹下面会有一个隐藏文件夹.git，此时就说明这个文件下下的所有内容都被git所管理。


然后新建一个文件，在内部输入一句话
vi test.txt

    hello git

此时执行命令
git status
会发现此时有一个test.txt文件状态是新增，并且没有被提交

所以此时我们就要把文件提交到本地仓库。
第一步
git add test.txt，或者git add ./* 表示提交当前文件夹下所有文件。
提交完后，进行第二步
git commit -m "xxxxxxx"
这里-m表示描述本次提交的一些信息，当然，既然是信息，我们肯定不推荐随便填写一些无用的内容。

这里就有疑问了，为什么git的提交会分为两步？
其实第一步add操作，只是把当前指定的文件提交到仓库标记而已，而并没有真正执行提交操作，所以此时我们可以进行多次add操作，当所有的add操作执行完毕后，统一执行一次commit操作即可。

此时第一个版本就提交完毕了，我们对这个文件进行修改，添加第二句话
modify txt。
此时保存后，我们用命令查看当前库的状态
git status，
发现此时test.txt有修改，但是并没有展示修改了什么，而git当然有方法来查看
git diff 即 difference的缩写，此时我们就可以看到两个不同版本的区别了。
然后继续进行git add操作，
此时再用git status查看，发现这个文件已经进入提交队列。
执行git commit，此时再用git status查看，发现已经没有待提交的文件了。

此时我们如果有一个需求，想回滚版本，又怎么办呢？
我们可以用
git log 或者git log --pretty=oneline来查看我们总共的提交记录
每一个提交，都有一个对应的commit Id。
所以我们就可以根据这个id进行回滚
git reset --hard HEAD^
其中HEAD^表示回滚到上一个版本，HEAD^^回滚到上两个版本，那么回滚到上100个版本，难道要输100个^吗？当然不是，我们可以直接用HEAD~100来回滚
不过前面提到，我们有commit id，所以我们可以直接指定commit id来进行回滚：
git reset --hard 12345
当我们回滚之后，打开文件，会发现我们最新修改的内容确实不见了，可见的确回滚到了之前的版本。
此时运行git log，发现此时最新的提交就是当前这个版本了，而回滚之前那个版本没有了，但是我们又想跳回到那个版本怎么办呢？
git当然可以有方法，
git reflog
可以查看到所有的版本记录，此时我们就可以找到那个版本对应的commit id了，既然有id，那么当然就可以回滚了。


此时我们再来一点进阶的
此时我们对一个文件进行了修改，但是没有提交，我们用git status命令查看，发现此时我们可以用
git checkout -- filename来进行撤销
注意--，是必须要的，不然的话，git checkout这个命令有额外的意思，即切换分支，这个概念后面在说
此时我们用命令进行撤销后，文件就回到了之前的版本
那么如果我们进行了add呢
此时执行checkout -- 命令，发现没有效果了，所以这里要注意，checkout --命令只会让文件回到上一次commit或者add之后的版本，我们前面进行了add，所以此时无论怎么checkout --，都只会回到这个add之后的状态，那么，我们如果进行了add，就不能提交了吗？
当然不是，我们可以通过
git reset HEAD filename来执行撤销当前add的操作
此时就回到了add之前的版本了，所以此时想撤销这个修改，就跟之前没提交时的方式一样了，通过checkout --来撤销修改。
不过上面的所有操作都有一个前提，就是只能在你的本地玩儿，如果你推送到了远程，或者另一个人，那么就真的没这么简单了。


