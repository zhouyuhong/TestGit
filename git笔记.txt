Git 教程：
git是一个分布式版本控制系统，并且是现在最流行的，最优秀的版本控制系统。
所谓分布式，即每一个用户都是一个完整的仓库，互不影响，如果此时有两个用户对同一个文件进行修改，git仅仅只需要让这两个用户互相推出自己的修改部分给对方即可，当然，实际开发中，我们很少直接面对面的进行推出，而是通过一个中间服务器进行推送，但是这个服务器仅仅承担推送的任务，没有它，git依旧可以运行。
这就有别于传统的集成式版本控制系统CVS、SVN，这两个被称为集成式的版本控制系统，与git最大的区别是它必须要一个服务里来作为版本管理中心，即仓库，用户必须从这个仓库下载文件，修改后也要提交到这个仓库中心才行，所以这就造成了一个弊端，即必须要有一个服务器，同时电脑必须能上网（局域网，广域网），如果没有这些条件，你是不能使用它们的。
这就是集成式版本控制系统与分布式版本控制系统的区别，虽然我们提到，git也有一个中间服务器，但是我们说过，这个服务器的作用仅仅是进行推送信息，即使没有它，git依旧能够完美运行。


git用法：
首先创建一个空文件夹，然后运行
git init

此时在这个文件夹下面会有一个隐藏文件夹.git，此时就说明这个文件下下的所有内容都被git所管理。同时，git会默认将本地仓库命名为master


然后新建一个文件，在内部输入一句话
vi test.txt

    hello git

此时执行命令
git status
会发现此时有一个test.txt文件状态是新增，并且没有被提交

所以此时我们就要把文件提交到本地仓库。
第一步
git add test.txt，或者git add ./* 表示提交当前文件夹下所有文件。
提交完后，进行第二步
git commit -m "xxxxxxx"
这里-m表示描述本次提交的一些信息，当然，既然是信息，我们肯定不推荐随便填写一些无用的内容。

这里就有疑问了，为什么git的提交会分为两步？
其实第一步add操作，只是把当前指定的文件提交到仓库标记而已，而并没有真正执行提交操作，所以此时我们可以进行多次add操作，当所有的add操作执行完毕后，统一执行一次commit操作即可。

此时第一个版本就提交完毕了，我们对这个文件进行修改，添加第二句话
modify txt。
此时保存后，我们用命令查看当前库的状态
git status，
发现此时test.txt有修改，但是并没有展示修改了什么，而git当然有方法来查看
git diff 即 difference的缩写，此时我们就可以看到两个不同版本的区别了。
然后继续进行git add操作，
此时再用git status查看，发现这个文件已经进入提交队列。
执行git commit，此时再用git status查看，发现已经没有待提交的文件了。

此时我们如果有一个需求，想回滚版本，又怎么办呢？
我们可以用
git log 或者git log --pretty=oneline来查看我们总共的提交记录
每一个提交，都有一个对应的commit Id。
所以我们就可以根据这个id进行回滚
git reset --hard HEAD^
其中HEAD^表示回滚到上一个版本，HEAD^^回滚到上两个版本，那么回滚到上100个版本，难道要输100个^吗？当然不是，我们可以直接用HEAD~100来回滚
不过前面提到，我们有commit id，所以我们可以直接指定commit id来进行回滚：
git reset --hard 12345
当我们回滚之后，打开文件，会发现我们最新修改的内容确实不见了，可见的确回滚到了之前的版本。
此时运行git log，发现此时最新的提交就是当前这个版本了，而回滚之前那个版本没有了，但是我们又想跳回到那个版本怎么办呢？
git当然可以有方法，
git reflog
可以查看到所有的版本记录，此时我们就可以找到那个版本对应的commit id了，既然有id，那么当然就可以回滚了。


此时我们再来一点进阶的
此时我们对一个文件进行了修改，但是没有提交，我们用git status命令查看，发现此时我们可以用
git checkout -- filename来进行撤销
注意--，是必须要的，不然的话，git checkout这个命令有额外的意思，即切换分支，这个概念后面在说
此时我们用命令进行撤销后，文件就回到了之前的版本
那么如果我们进行了add呢
此时执行checkout -- 命令，发现没有效果了，所以这里要注意，checkout --命令只会让文件回到上一次commit或者add之后的版本，我们前面进行了add，所以此时无论怎么checkout --，都只会回到这个add之后的状态，那么，我们如果进行了add，就不能提交了吗？
当然不是，我们可以通过
git reset HEAD filename来执行撤销当前add的操作
此时就回到了add之前的版本了，所以此时想撤销这个修改，就跟之前没提交时的方式一样了，通过checkout --来撤销修改。
不过上面的所有操作都有一个前提，就是只能在你的本地玩儿，如果你推送到了远程，或者另一个人，那么就真的没这么简单了。

前面都是在本地玩，接下来我们就介绍一下如何与远程仓库关联
首先，我们需要一个远程仓库，github就是其中的佼佼者，我们注册一个账号之后
在上面创建一个仓库，然后获取这个仓库的url
接下来就是将本地与远程进行关联了
git remote add 远程仓库名 url
举个例子：
git remote add origin xxxxxx.git
此时就表示将本地仓库与远程的xxx仓库进行关联，并且将远程仓库命名为origin，以后就可以用Origin来代替远程仓库，而不用每次都输入后面的Url了。
关联好之后，接下来我们就进行第一次远程推送
git push
由于是第一次，此时远程仓库还没有任何信息，所以我们用
git push -u origin master来进行推送
origin不用说，就是前面的远程仓库，而后面的master表示本地仓库，前面提到过
-u表示git不但会把本地的master推送到远程，同时也会在远程创建master，并且与本地的master进行关联，之后的所有需要提交的代码，都可以用
git push origin master来简化了。


接下来介绍一下分支
我们往往会有这种需求，我们此时在开发，如果都是只针对master主分支进行修改，那么每次提交后，必然会影响master的代码，如果此时线上有一个问题需要修复，此时master已经有我们新写的代码了，显然此时如果对master直接修复，会导致我们没有开发完成的代码也会一并发布出去，显然是不科学的，所以此时我们就可以创建一个分支。新的需求就在分支上修改，当我们开发完成之后，再合并到master上即可。
首先我们创建一个分支
git checkout -b dev
-b表示创建分支，checkout表示切换分支
所以此时本地HEAD指针就指向了dev这个分支
我们查看一下
git branch
发现dev分支前面有*号，表示当前是在dev上开发
此时我们修改test.txt文件，然后add并commit
做完上述的操作后，我们再次切换到master
git checkout master
此时打开test.txt文件，发现我们前面添加的内容不见了，这就证明了我们前面是在dev分支上做的提交
此时我们可以直接将dev推送到远程仓库
git push origin dev
这时远程仓库就有master和dev两个仓库了
但是我们master还没有改变，此时我们就可以用合并命令，将dev的内容合并到master
git merge dev
此时dev修改的内容就合并到了master的txt文件中，然后我们就可以删除本地的分支了
git branch -d dev
删完后，查看git branch
的确只剩下master主分支
然后提交，此时远程仓库的master就更新了
但是此时我们会发现，远程的dev还没有删除，怎么办呢？我们可以运行如下的命令删除远程的分支
git push origin --delete branchname
所以我们此时就可以输入
git push origin --delete dev
来删除远程分支


但是我们知道，在多个分支同时修改后，合并会有一定几率发生冲突，比如此时我们在dev中修改txt文件内容。然后add并commit
然后此时我们切换到master，同样对txt文件进行修改，并add和commit
此时我们再进行合并操作，就会发现git提示我们txt发生了冲突，需要解决
我们打开txt文件，发现两个版本的内容都被git标记了出来，我们手动修改之后，进行add与commit，此时冲突就解决完毕了
此时我们也可以通过git命令来查看日志记录，冲突也清晰的展示了出来
git log --graph --pretty=oneline --abbrev-commit
直接输入
git log --graph
可以只查看冲突解决的图例


接下来就介绍一下如果出现Bug，此时怎么办
假设此时我们的master上出现了一个bug